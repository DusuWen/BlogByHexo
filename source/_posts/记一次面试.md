---
title: 面试题合集（持续更新）
date: 2019-05-30 19:24:35
tags:面试
---
### Javascript的几种数据类型

最新的ECMAScript标准定义了7中数据类型：

- 6种原始类型
  - Boolean
  - Null
  - Undefined
  - Numer
  - String
  - Symbol(ECMAScript6 新定义)
- 和Object

### 如何判断一个Javascript数据类型

#### typeof 操作符

`typeof`是`javascript`原生提供的判断数据类型的运算符，它会返回一个表示参数的数据类型的字符串，但是需要注意的是，`Null`会返回object，数组属于Any other object也会返回object。

```javascript
const a = null;
const b = {};
const c= [];
console.log(typeof(a)); //Object
console.log(typeof(b)); //Object
console.log(typeof(c)); //Object
```

#### instanceof运算符

`instanceof`运算符可以用来判断某个构造函数的`prototype`属性所指向的对象是否存在于另外一个要检测对象的原型链上。

```javascript
const a = [];
const b = {};
console.log(a instanceof Array);//true
console.log(a instanceof Object);//true,在数组的原型链上也能找到Object构造函数
console.log(b instanceof Array);//false
```

#### Object.prototype.toString

每一个继承自`Object`的对象都拥有`toString`的方法，如果一个对象的`toString`方法没有被重写过的话，那么`toString`方法将会返回"[object *type*]"，其中的*type*代表的是对象的类型。

```javascript
const a = ['Hello','Howard'];
const b = {0:'Hello',1:'Howard'};
const c = 'Hello Howard';
Object.prototype.toString.call(a);//"[object Array]"
Object.prototype.toString.call(b);//"[object Object]"
Object.prototype.toString.call(c);//"[object String]"
```

除了使用`call()`，还可以使用`apply()`

但是，`Object`原型链上的`toString`方法可以被重写，如果修改过`toString`方法，就无法准确判断数据类型

#### constructor

实例化的数组拥有一个`constructor`属性，这个属性指向生成这个数组的方法。

```javascript
const a = [];
console.log(a.constructor);//function Array(){ [native code] }
const b = {};
console.log(b.constructor);//function Object(){ [native code] }
```

但是，`constructor`属性可以被改写，如果修改过`constructor`属性，就无法准确判断数据类型。

#### Array.isArray()

用来判断一个变量是否为数组，无论是修改`Object.prototype.toString`方法还是`constructor`属性都不会影响判断结果。

```javascript
const a = [];
const b = {};
Array.isArray(a);//true
Array.isArray(b);//false
```

### Vue实现数据绑定的原理

当把一个`javascript`对象传递给`vue`实例的`data`选项时，`vue`将遍历这个对象的所有属性，并使用`object.defineProperty`把这些属性转变为`getter`和`settter`。每个组件实例都有相应的`watcher`实例对象，它会在组件渲染过程中把属性记录为依赖，当依赖的`setter`被调用时，会通知`watcher`重新计算，`watcher`通过依赖找到使用`getter`获取该属性值的组件，并通知该组件重新渲染，渲染完成后再次把属性记录为依赖存入`watcher`实例。

![如何追踪变化](https://cn.vuejs.org/images/data.png)

注意事项

- Vue不能检测到对象属性的添加或删除
- Vue不允许动态添加根基响应式属性

对于第一个问题可以采用`Vue.set(object, key, value)`方法来条线响应属性。对于第二个问题，只能在初始化实例前声明根级响应式属性，哪怕只是一个空值。

### 为什么vue 组件里 data 必须是一个function
因为每一次使用新的组件，都会有一个新的实例被创建，一个组件的`data`必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝

#### Proxy相比Object.defineProperty的优势是什么
`Object.defineProperty`的问题主要有三个

- 不能监听数组的变化
- 必须遍历对象的每个属性
- 必须深层遍历嵌套的对象
- 无法监听对象属性的增加和删除

`Proxy`的几个特点

- 针对对象
- 支持数组
- 支持13种拦截方式
- 作为新标准收到浏览器厂商的重点关注和性能优化

### computed与methods

计算属性是基于他们的依赖进行缓存的，只有在相关依赖发生改变时才会重新求值。相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。

### http状态码

- 1xx消息
- 2xx成功
- 3xx重定向
- 4xx客户端错误
- 5xx服务器错误

### cookie和session 的区别

- 存取方式的不同
- 隐私策略的不同
- 有效期上的不同
- 服务器压力的不同
- 浏览器支持的不同
- 跨域支持上的不同

### Promise 链式调用

《ECMAScript 6 入门》一书中，阮一峰在[Promise对象](http://es6.ruanyifeng.com/#docs/promise)介绍`Promise` 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。

`then`方法接受两个参数，第一个是`resolved`状态的回调函数，第二个（可选）是rejected状态的回调函数。同时，`then`方法返回一个新的Promise实例，因此可以采用链式写法，在一个`then`后再掉调用一个`then`，而后一个then方法依旧可以接受两个参数的。

```javascript
getJSON("/post/1.json").then(function(post) {
  return getJSON(post.commentURL);
}).then(function funcA(comments) {
  console.log("resolved: ", comments);
}, function funcB(err){
  console.log("rejected: ", err);
});
```

需要注意的是，一般使用`Promise`时总是配合`catch`方法使用，所以，此时不要在`then`方法里面定义Reject状态的回调函数，直接使用`catch`方法。好处是，`catch`方法总是可以捕获到在`then`方法执行过程中产生的Error，有利于后期排查。

```javascript
// bad
promise
  .then(function(data) {
    // success
  }, function(err) {
    // error
  });

// good
promise
  .then(function(data) { //cb
    // success
  })
  .catch(function(err) {
    // error
  });
```

一般总是建议，Promise 对象后面要跟`catch`方法，这样可以处理 Promise 内部发生的错误。`catch`方法返回的还是一个 Promise 对象，因此后面还可以接着调用`then`方法。而且，`catch`方法之后还可以继续执行`then`方法，甚至`catch`方法之后还可以执行`catch`方法。

在调用`then`方法实现链式调用时需要特别注意如何处理错误，没有`catch`住的错误会被`Promise`’吃掉‘

### Vue中对Array的检测做了什么特殊处理

由于`Object.defineProperty`不能监听数组的变化，需要进行数组方法的重写，所以在Vue.js官方文档中[数组更新检测](https://cn.vuejs.org/v2/guide/list.html)中提到Vue提供一组观察数组的变异方法，使用这些方法才可以触发视图更新。

同时，文档中提到，由于Javascript的限制

- 利用索引直接设置一个项
- 直接修改数组长度

都不会触发视图更新，需要使用`vm.$set`和`splice`方法

### 简述同源策略

同源的三个要素

- 协议相同
- 端口相同
- 域名相同

当某个页面上执行的`ajax`请求的`url`与该页面的url中有上面三个中的任何一个不一样，就会产生跨域问题

解决跨域最常见的方案是后台服务端在`Response-Header`中设置`Access-Control-Allow-Origin`

### F5 和Ctrl+F5的区别

在页面上使用`F5`和`Ctrl+F5`都可以实现刷新当前页面，不同点是`F5`会使用当前浏览器对该页面的缓存资源，`Ctrl+F5`会强制从服务器获取资源

#### 请求中的size

打开控制面板查看`Network`中的资源请求，可以看到`size`一列中会出现4种情况

- 资源的大小
- `from disk cache`
- `from memory cache`
- `from ServiceWorker`

##### from memory cache

表示该请求资源取自内存，不会再向服务器请求，关闭当前页面资源被释放

##### from disk cache

表示该请求资源取自磁盘，不会再向服务器请求，关闭当前页面资源不会被释放

##### 资源的大小

当http状态码为200时，表示从服务器获取的资源大小

当http状态码为304时，表示与服务器通信报文的大小，不是资源的大小，此时资源从本地获取

##### from ServiceWorker

表示该资源取自ServiceWorker

#### 造成size多重情况的原因

是因为使用`F5`和`Ctrl+F5`两种方式发送的请求头不一样（不同浏览器有些许差异）

##### F5 在chrome中

按`F5`后，请求状态码是200，资源的请求头中会有`provisional headers are show`字样，表示未与服务端正确通信，详细表头也不会显示，强缓存 `from disk cache`或者`from memory cache`都不会正确显示请求头

##### F5 在firefox中

按`F5`后，请求的状态码是304 Not Modified，这是因为firefox在`F5`发送请求时会在请求头添加`If-Modified-Since`字段，如果资源未过期，命中缓存，服务器会直接返回304状态码，浏览器会直接使用本地资源，这就是协商缓存

##### Ctrl+F5 在chrome和firefox中

请求头中多了`Cache-Control:no-cache`和`Prafma:no-cache`表示浏览器不接受本地缓存的资源，需要到源服务器进行资源请求，但是这个过程中其实可以使用缓存服务器中资源，不过需要到源服务器进行验证，验证通过才可以将缓存服务器的资源返回给浏览器